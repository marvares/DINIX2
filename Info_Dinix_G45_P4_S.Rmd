---
title: "Informe Estandarizaci칩n Per칰 Escala INDI, Parte 4: An치lisis de Regresi칩n"
subtitle: "Muestra Nivel 4-5"
author: "Mart칤n Vargas Estrada"
date: "`r Sys.time()`"
output:
  pdf_document:
    toc: true
    toc_depth: 4
  word_document:
    toc: true
    toc_depth: '4'
  html_document:
    toc: true
    toc_depth: '4'
    df_print: paged
header-includes: \renewcommand{\contentsname}{칈ndice} \renewcommand{\tablename}{Tabla}
---
\newpage

# Introducci칩n


Informe de Exploraci칩n Psicom칠trica de los 칤tems de la prueba INDI obtenidas con muestra de Per칰, Niveles 4-5. 

```{r 45_P4_DATAFRAME, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE, results='asis'}

library(tidyverse)
library(haven)
rm(list = ls()) 
# Carga el archivo .sav
INDI45 <- read_sav("INDI45.sav")

invertir_y_sumar <- function(df, indices_inversos, nombre_variable_sumatoria, posicion_variable) {
  
  # Asegurar que df sea un tibble para evitar problemas con select()
  df <- as_tibble(df)
  
  # 1. Convertir columnas 75:88 a num칠ricas
  df <- df %>%
    mutate(across(74:86, as.numeric))
  
  # 2. Invertir los 칤tems indicados
  df <- df %>%
    mutate(across(indices_inversos, ~ 7 - .x))
  
  # 3. Crear la variable sumatoria
  df <- df %>%
    mutate(!!nombre_variable_sumatoria := rowSums(across(74:86)))
  
  # 4. Reubicar la variable sumatoria en la posici칩n deseada
  col_order <- names(df)  # Obtener nombres de columnas
  col_order <- setdiff(col_order, nombre_variable_sumatoria)  # Remover sumatoria si ya est치
  col_order <- append(col_order, nombre_variable_sumatoria, after = posicion_variable - 1)  # Insertar en posici칩n
  
  # 游늷 Reordenar usando 칤ndice de columnas en lugar de dplyr::select()
  df <- df[, col_order]  # 拘勇 Esto funciona siempre

  return(df)
}





# Ejemplo
# Aplicar la funci칩n con los valores indicados
INDI45_i <- invertir_y_sumar(
  df = INDI45,
  indices_inversos = c(77:80, 84:88),  # 칈tems inversos
  nombre_variable_sumatoria = "SSUM",  # Nombre de la variable sumatoria
  posicion_variable = 104  # Ubicaci칩n deseada
)

```


# An치lisis de Regresi칩n entre el valor de las Escalas  y las Variables Demogr치ficas

## Introducci칩n 

El objetivo de esta secci칩n realizar un an치lisis de regresi칩n entre el valor de las escalas y las diferentes variables demogr치ficas cuya informaci칩n fue recabada durante la investigaci칩n. 

Cabe especificar el sentido del an치lisis de regresi칩n, ya que, a diferencia de los anteriores, es f치cil malentenderlo y su significado no es evidente a primera vista.

El objetivo del an치lisis de regresi칩n es encontrar una relaci칩n de causalidad entre una o m치s variables independientes, y una variable dependiente. Esta 칰ltima es la "estrella" de nuestro an치lisis; en contra de lo que pudiera parecer, la variable dependiente es en realidad la principal, la que motiva toda la pesquisa estad칤stica. Estamos interesados determinar si ciertas variables pueden ayudarnos a explicar y/o predecir a nuestra variable dependiente. 

Una variable es "independiente" en el sentido de que, dentro de nuestra teor칤a y/o nuestro sentido com칰n, ciertas variables podr칤an causar o predecir a nuestra variable dependiente, y esta relaci칩n, te칩ricamente, deber칤a ser unidireccional. Por ejemplo, cuando decimos que la *variable independiente* es la Edad del participante y nuestra *variable dependiente* es el puntaje en la escala Cognitiva del INDI, estamos planteando la posibilidad de que la edad nos ayude a explicar y/o predecir el desempe침o en el INDI, y plantearnos una relaci칩n inversa (쯘l puntaje influenciando a la Edad?) o incluso rec칤proca (쮼dad y desempe침o en el INDI influenci치ndose mutuamente?) no tendr칤a sentido. 

A veces, la l칩gica la define nuestro sentido com칰n (claramente la edad, por definici칩n, no es influenciada por ning칰n tipo de acci칩n del participante); a veces es determinada por la teor칤a que nos gu칤a para plantear toda la investigaci칩n en primer lugar. 

## Interpretaci칩n General de los Resultados de la Regresi칩n

1. **Qu칠 es la ecuaci칩n de regresi칩n**. En primer lugar, es importante entender cu치l es el sentido de la regresi칩n. Recordemos que nuestro prop칩sito es explicar/predecir los valores de una variable dependiente a partir de variables independientes. Explicar significa en este caso definir una ecuaci칩n que describa el comportamiento de la variable dependiente. En esa ecuaci칩n la variable dependiente ser치 el resultado (es decir, ir치 antes del signo "=") y las variables independientes ser치n los sumandos que al agregarse resultan en el valor que la variable dependiente tomar치 seg칰n el caso.

En t칠rminos matem치ticos:

$$ Y=\beta_0+\beta_1X_1+\beta_2X_2+\ldots+\beta_nX_n $$
Cada valor $X$ representa una variable (num칠rica o categ칩rica), y cada valor $\beta$ un coeficiente que pondera el valor que cada variable asume para poder as칤 determinar un valor dado que asumir치 la variable dependiente $Y$. El sub칤ndice se usa para especificar que el coeficiente ser치 distinto para cada variable independiente.

El coeficiente $\beta_0$ es lo que se llama *intercepto*; es el valor que asume la variable dependiente cuando todas las variables independientes asumen un valor cero. 

2. **Qu칠 significan las variables *dummy* en el contexto del tratamiento estad칤stico de la regresi칩n**. Cada vez que incluimos una variable categ칩rica (es decir, una variable cuyos valores no son num칠ricos, sino m치s bien categor칤as; ejemplo: Regi칩n, cuyos valores ser칤an las categor칤as "Costa", "Sierra", y "Selva"), nos vemos obligados a utilizar un algoritmo que nos permita incluir esas variables en el c치lculo. Ese algoritmo o m칠todo consiste en asumir como referencia la primera categor칤a de la variable, y luego pasar a incluir las dem치s categor칤as como si se tratase de variables distintas, convirti칠ndolas en variable dicot칩micas.

En el caso de nuestro ejemplo, si nuestra variable es "Regi칩n", y las categor칤as son Costa, Sierra y Selva, entonces podemos asumir la categor칤a "Costa" como valor de referencia; cuando un participante pertenezca a la Regi칩n "Sierra", lo traduciremos en t칠rminos de variables *dummy* como un "1" en la variable *Regi칩nSierra*. Si el participante no pertenece a la la Regi칩n Sierra, tendr치 un "0" en la variable *Regi칩nSierra*. Igual haremos con todos los dem치s casos de variables categ칩ricas. 

Esto tiene una enorme ventaja: nos permite tratar a las variables categ칩ricas como si fueran variables dicot칩micas num칠ricas, haciendo posible incluirlas en la ecuaci칩n de regresi칩n. Pero tiene una gran desventaja: nos obliga a tener mucho cuidado al momento de interpretar la ecuaci칩n. 

Pongamos un ejemplo para clarificar: imaginemos que estamos tratando de explicar la variable Escala Cognitiva a partir de la variable Edad y la variable Regi칩n. Es decir, 

$$ Y=EscalaCognitiva, X_1=Edad, X_2=Regi칩n $$
Con la variable Edad no tendremos problema porque se trata de una variable num칠rica. No es el caso con la variable Regi칩n. Tomaremos la categor칤a "Costa" como referencia; por lo tanto, cuando tengamos un participante de la Costa sencillamente tomaremos el valor del intercepto ($\beta_0$) como el aporte de la variable *Regi칩nCosta*. Si el participante proviene, por el contrario, de la Sierra, entonces tendremos que la variable Regi칩nSierra=1, y la variable Regi칩nSelva=0. Todas las variables independientes con valor cero ser치n eliminadas de la ecuaci칩n porque tendr치n valor nulo, y solo quedar치n las variables independientes con valor distinto de cero. Para fines de nuestro ejemplo, asumamos que:

$$ 
\beta_0=1.2; \beta_1=0.9; X_1=Edad; \beta_2=2.7; X_2=RegionSierra; \beta_3=4.1; X_3=RegionSelva
$$


Por lo tanto, nuestra ecuaci칩n de regresi칩n quedar치 como sigue:

$$ EscalaCognitiva = 1.2 + 0.9*Edad + 2.7*RegionSierra + 4.1*RegionSelva $$
Si un participante pertenece a la Regi칩n Costa y tiene una edad de 40 meses, entonces nuestro modelo predice que:

$$ EscalaCognitiva = 1.2 + 0.9*40 + 2.7*0 + 4.1*0 $$
Es decir, 

$$ EscalaCognitiva = 37.2 $$

### Regresi칩n y Correlaci칩n 

La diferencia clave entre la regresi칩n y la correlaci칩n es que, mientras la correlaci칩n solo mide asociaci칩n entre variables, la regresi칩n trata de determinar la *causalidad* de una o m치s variables (llamadas independientes) sobre otra (llamada dependiente).

Otra diferencia importante es que mientras la correlaci칩n solo describe la asociaci칩n o co-ocurrencia entre dos variables, *la regresi칩n est치 dise침ada de tal modo que nos ayuda a determinar en qu칠 medida una variable independiente explica el comportamiento de la dependiente*. Como luego veremos, es completamente posible, como resultado de un an치lisis de regresi칩n, establecer en qu칠 porcentaje una variable independiente X nos ayuda a explicar el comportamiento o variabilidad de los datos de una variable dependiente.

Finalmente, una tercera distinci칩n fundamental es que mientras que la correlaci칩n se limita *describir* la co-ocurrencia de dos conjuntos de datos ya existentes, el an치lisis de regresi칩n nos permite *predecir* valores de la variable dependiente a partir de valores de las variables independientes, *incluso si tales valores no se dan en nuestra muestra*. 

### Regresi칩n como descriptor de una relaci칩n lineal

Antes de pasar a ver los resultados, debemos tener en cuenta que el tipo de an치lisis de regresi칩n que pasaremos a ejecutar se basa en el supuesto de que existe una relaci칩n lineal entre el conjunto de variables independientes y los puntajes en las escalas INDI. Es decir, que el efecto de las variables independientes es constante, va en una sola direcci칩n y no cambia de sentido. Por ejemplo,  si asumimos una relaci칩n lineal entre Edad en Meses y Puntaje en el INDI, estaremos asumiendo que el aumento de un mes en la Edad mejorar치 el desempe침o en el INDI, y esto no cambiar치 y adem치s es constante (el incremento de un mes en la edad deber칤a tener el mismo efecto en el puntaje, sin importar la edad del participante).

Es posible que la relaci칩n entre una variable dependiente y una o m치s variables independientes sea no lineal; en ese caso, el resultado de una regresi칩n lineal ser치 nulo, sin que esto necesariamente implique falta de relaci칩n en general. Tan solo estar칤amos hablando de falta de relaci칩n *lineal*. 

Habiendo dicho esto, por lo general la regresi칩n lineal es la que se analiza, ya que se trata del modelo m치s frecuente y sencillo de entender y de evaluar. Salvo que nuestra teor칤a establezca lo contrario, ser치 el tipo de regresi칩n que usaremos. 


## Variables Demogr치ficas Consideradas (Variables Independientes)

Consideraremos las siguientes variables:

1. Edad en Meses
1. Fecha de Eval
1. Regi칩n
1. 츼rea
1. Modalidad
1. Gesti칩n
1. Departamento
1. Quintil
1. Inst. Mat.
1. Inst. Pat.
1. Inst. Previa al Nivel 3

```{r 45_P4_DATAFRAMING, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE, results='asis'}

# Funci칩n para extraer la data num칠rica sin NA's de un df

ayudin <- function(dataframe, columnas) {
  # Verificar que las columnas seleccionadas sean num칠ricas
  if (!all(sapply(columnas, function(col) is.numeric(dataframe[[col]])))) {
    stop("Todas las columnas seleccionadas deben ser num칠ricas.")
  }
  
  # Filtrar el dataframe eliminando filas con NA en las columnas seleccionadas
  dataframe_limpio <- dataframe[complete.cases(dataframe[, columnas]), columnas]
  
  # Devolver el dataframe limpio
  return(dataframe_limpio)
}

# Llamar a la funci칩n y mostrar los resultados
LIMPIO <- ayudin(dataframe = INDI45_i, columnas = c(1, 102:105))

# DF Categorial
# Funci칩n para convertir variables a factor
convert_to_factor <- function(df, indices) {
  df[indices] <- lapply(df[indices], as.factor)
  return(df)
}
# Convierto a factor

INDI45_Factor<- convert_to_factor(INDI45_i, c(2,7:9,13,19:20,41))
# Me quedo solo con las variables factor
library(dplyr)
INDI45_Factor <- INDI45_Factor %>% 
  dplyr::select(Codigo, EDADMES, Fechin, Regnat, Area, Nivmod, Reg, Quintil, Grainsmad, Grainspad, Insant3a)
# Fusiono con el df num칠rico sin NA's
PULCRO <- left_join(LIMPIO, INDI45_Factor,  by = "Codigo") # Este df solo tiene casos sin NA's y con las variables factor

# Ahora voy a reetiquetar los niveles de los factores y, de ser caso, rebautizarlos.

library(forcats)
# Recodificar niveles
PULCRO$Fechin <- fct_recode(PULCRO$Fechin,
                        "Abr." = "2024-04-29",
                        "May." = "2024-05-20",
                        "Jun." = "2024-06-17",
                        "Ago." = "2024-08-12")
PULCRO$Regnat<- fct_recode(PULCRO$Regnat,
                        "Costa" = "1",
                        "Sierra" = "2",
                        "Selva" = "3")

PULCRO$Area <- fct_recode(PULCRO$Area,
                        "Urbana" = "1",
                        "Rural" = "2")

PULCRO$Nivmod <- fct_recode(PULCRO$Nivmod,
                        "Jard칤n" = "Inicial - Jard칤n",
                        "No_Esc" = "Inicial - Programa no escolarizado",
                        "Cuna-Jard칤n" = "Inicial - Cuna-jard칤n"
                        )
# PULCRO$Gest <- fct_recode(PULCRO$Gest,
#                         "P칰blica" = "1",
#                         "Privada" = "2")
PULCRO$Reg <- fct_recode(PULCRO$Reg,
                        "Lima Met." = "Lima Metropolitana",
                        "Piura" = "Piura",
                        "Cusco" = "Cusco",
                        "Loreto" = "Loreto"
                        )

colnames(PULCRO) <- c("C칩digo", "Escala_Cog.", "Escala_Mot.", "Escala_Soc", "Escala_Dis.","Edad_Mes", "Fecha_Eval", "Regi칩n", "츼rea", "Modalidad", "Departamento", "Quintil", "Inst_Mat.", "Inst_Pat.", "Inst_Pre_N3")

PULCRO$Inst_Mat. <- fct_relevel(PULCRO$Inst_Mat., "Ninguno", "Inicial", "Primaria incompleto", "Primaria completo", "Secundaria incompleto", "Secundaria completo","Superior t칠cnico incompleto", "Superior t칠cnico completo","Superior universitario incompleto","Superior universitario completo","Posgrado (maestr칤a, doctorado)")

PULCRO$Inst_Pat. <- fct_relevel(PULCRO$Inst_Pat., "Ninguno", "Inicial", "Primaria incompleto", "Primaria completo", "Secundaria incompleto", "Secundaria completo","Superior t칠cnico incompleto", "Superior t칠cnico completo","Superior universitario incompleto","Superior universitario completo","Posgrado (maestr칤a, doctorado)")

PULCRO$Inst_Pre_N3  <- fct_recode(PULCRO$Inst_Pre_N3,
                        "No" = "0",
                        "S칤" = "1",
                        "NS/NR" = "2"
                        )

# Filtro los casos de Modalidad No escolarizada, al ser un grupo demasiado peque침o
PULCRO <- PULCRO %>% 
  filter(Modalidad != "No_Esc")
# Como hay colinearidad Perfecta entre Fecha_Eval y Dpto, elimino Fecha Eval
PULCRO <- PULCRO %>% select(-Fecha_Eval)

```

Las variables dicot칩micas de Incidencia (codificadas como VSS y similares) y Tratamiento (RSS y similares) no fueron consideradas para este an치lisis, ya que definen subgrupos extremadamente peque침os (menos del 5%,; en la mayor칤a de casos, menos del 3%) y tomarlas en cuenta distorsionar칤a los resultados, al obligar a tomar medidas de ajuste que a su vez introducir칤an nuevos sesgos. Lo mismo sucede con los casos de la variable Gesti칩n, y el peque침o grupo perteneciente a la categor칤a "No escolarizado" dentro de la variable "Modalidad".

\newpage

## An치lisis 1: Escala Cognitiva como Variable Dependiente

A continuaci칩n determinaremos qu칠 tan 칰til es un an치lisis de regresi칩n para intentar explicar/predecir los puntajes en la escala Cognitiva del INDI a partir de las variables independientes ya mencionadas.  




```{r 45_P4_REG_CSUM, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE, results='asis'}

# Defino s칰per funci칩n que me bota los resultados de la regresi칩n m칰ltiple en formato PTM
regmulti <- function(df, var_dep, var_ind, nombres_vars = NULL, nombre_dep = NULL) {
  library(knitr)  # Para kable
  library(dplyr)  # Para manipulaci칩n de datos
  
  # Obtener el nombre original de la variable dependiente
  var_dep_name <- deparse(substitute(var_dep))
  
  # Si el usuario proporciona un nombre para la variable dependiente, usarlo
  if (is.null(nombre_dep)) {
    nombre_dep <- var_dep_name
  }
  
  # Extraer nombres originales de las variables independientes
  nombres_ind <- names(df)[var_ind]
  
  # Si el usuario proporciona nombres personalizados, validamos que sean del mismo tama침o
  if (!is.null(nombres_vars)) {
    if (length(nombres_vars) != length(nombres_ind)) {
      stop("El n칰mero de nombres en 'nombres_vars' debe coincidir con el n칰mero de variables independientes proporcionadas.")
    }
  } else {
    nombres_vars <- nombres_ind  # Usar los nombres originales si no se proporcionan personalizados
  }
  
  # Construcci칩n de la f칩rmula de regresi칩n
  formula_reg <- as.formula(paste(var_dep_name, "~", paste(nombres_ind, collapse = " + ")))
  
  # Ajustar el modelo de regresi칩n
  modelo <- lm(formula_reg, data = df)
  
  # Obtener coeficientes y p-valores
  resultados <- summary(modelo)$coefficients
  coeficientes <- resultados[, 1]
  p_valores <- resultados[, 4]
  
  # Obtener nombres de los coeficientes generados (incluye dummies)
  nombres_coeficientes <- rownames(resultados)
  
  # Construcci칩n autom치tica de nombres personalizados si hay variables categ칩ricas
  if (!is.null(nombres_vars)) {
    # Crear un mapeo entre nombres originales y personalizados
    nombres_dict <- setNames(nombres_vars, nombres_ind)
    
    # Reemplazar nombres en coeficientes, conservando variables dummy
    nombres_coeficientes <- sapply(nombres_coeficientes, function(var) {
      for (orig in nombres_ind) {
        if (grepl(orig, var)) {
          return(gsub(orig, nombres_dict[[orig]], var))
        }
      }
      return(var)  # Si no se encuentra en el diccionario, mantener el nombre original
    })
  }
  
  # Asignar notaci칩n de significancia
  significancia <- ifelse(p_valores < 0.001, "***",
                          ifelse(p_valores < 0.01, "**",
                                 ifelse(p_valores < 0.05, "*", "NS")))
  
  # Crear la tabla de resultados
  tabla_resultados <- tibble::tibble(
    Variable = nombres_coeficientes,
    Coeficiente = round(coeficientes, 3),
    `p-valor` = round(p_valores, 4),
    Significancia = significancia
  )
  
  # ---- Construcci칩n de la ecuaci칩n de regresi칩n con t칠rminos significativos ----
  # Seleccionamos solo coeficientes con p-valor < 0.05 (significativos)
  indices_significativos <- which(p_valores < 0.05)
  
  # Si solo el intercepto es significativo, ecuaci칩n ser치 solo ese valor
  if (length(indices_significativos) == 1 && indices_significativos == 1) {
    ecuacion <- paste0(nombre_dep, " = ", round(coeficientes[1], 3), " + 풧")
  } else {
    coef_significativos <- coeficientes[indices_significativos]
    nombres_significativos <- nombres_coeficientes[indices_significativos]
    
    terminos <- paste0(
      ifelse(coef_significativos[-1] >= 0, "+ ", "- "), abs(round(coef_significativos[-1], 3)), " * ", nombres_significativos[-1]
    )
    
    ecuacion <- paste0(
      nombre_dep, " = ", round(coef_significativos[1], 3), " ",
      paste(terminos, collapse = " ")
    )
  }
  
  # Obtener el R ajustado
  r_cuadrado_ajustado <- round(summary(modelo)$adj.r.squared, 4)
  
  # ---- Imprimir resultados ----
  cat("\n### Regresi칩n entre", nombre_dep, "y", paste(nombres_vars, collapse = ", "), "\n")
  print(kable(tabla_resultados, format = "markdown", align = "c"))
  cat("\n**La ecuaci칩n de regresi칩n obtenida es (solo coeficientes significativos):**\n\n", ecuacion, "\n")
  cat("\n**R Cuadrado Ajustado:**", r_cuadrado_ajustado, "\n")
}

# La uso, muy quitado de la pena:
regmulti(PULCRO, PULCRO$Escala_Cog., c(6:14), nombres_vars = c("Edad en Meses", "Regi칩n", "츼rea", "Modalidad", "Departamento", "Quintil", "Educac. Materna", "Educac. Paterna", "Instrucci칩n Previa"), nombre_dep = "Escala Cognitiva")
```

La informaci칩n anterior nos indica que:

1. Usar todas las variables que hemos recolectado para predecir el puntaje en la Escala Cognitiva del INDI nos genera un modelo que solo puede explicar menos del 32% de la variabilidad de los datos. Esto significa que casi el 69% del comportamiento de la Escala Cognitiva del INDI se debe a factores no considerados dentro de este estudio. 
1. Las 칰nicas variables que realmente aportan a la explicaci칩n del puntaje en la Escala Cognitiva INDI son: 
  
  a. Edad
  b. Departamento (con excepci칩n de Piura)
  c. Quintil (con la excepci칩n del Quintil 3; en el caso del Quintil 2 y 4, va en detrimento)
  d. Que la Educaci칩n Materna sea de Nivel Inicial
  

\newpage

## An치lisis 2: Escala Motora como Variable Dependiente

A continuaci칩n determinaremos qu칠 tan 칰til es un an치lisis de regresi칩n para intentar explicar/predecir los puntajes en la escala Motora del INDI a partir de las variables independientes ya mencionadas.  

```{r 45_P4_REG_MSUM, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE, results='asis'}
regmulti(PULCRO, PULCRO$Escala_Mot., c(6:14), nombres_vars = c("Edad en Meses", "Regi칩n", "츼rea", "Modalidad", "Departamento", "Quintil", "Educac. Materna", "Educac. Paterna", "Instrucci칩n Previa"), nombre_dep = "Escala Motora")
```

La informaci칩n anterior nos indica que:

1. Usar todas las variables que hemos recolectado para predecir el puntaje en la Escala Motora del INDI nos genera un modelo que solo puede explicar menos del 25% de la variabilidad de los datos. Esto significa que m치s del 75% del comportamiento de la Escala Motora del INDI se debe a factores no considerados dentro de este estudio. 
1. Las 칰nicas variables que realmente aportan a la explicaci칩n del puntaje en la Escala Cognitiva INDI son: 
  
  a. Edad
  a. Departamento (excepto Piura)
  a. Que el participante provenga de la Regi칩n Costa o Selva (en ese caso, va en detrimento)
  a. Que el participante sea de Modalidad Jard칤n
  a. Quintil (con la excepci칩n del Quintil 5; en todos los casos, va en detrimento)
  a. Que la madre tenga un nivel educativo de Postgrado
  

\newpage


## An치lisis 3: Escala Socioemocional como Variable Dependiente

A continuaci칩n determinaremos qu칠 tan 칰til es un an치lisis de regresi칩n para intentar explicar/predecir los puntajes en la escala Motora del INDI a partir de las variables independientes ya mencionadas.  

```{r 45_P4_REG_SSUM, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE, results='asis'}
regmulti(PULCRO, PULCRO$Escala_Soc, c(6:14), nombres_vars = c("Edad en Meses", "Regi칩n", "츼rea", "Modalidad", "Departamento", "Quintil", "Educac. Materna", "Educac. Paterna", "Instrucci칩n Previa"), nombre_dep = "Escala Socioemocional")
```

La informaci칩n anterior nos indica que:

1. Usar todas las variables que hemos recolectado para predecir el puntaje en la Escala Motora del INDI nos genera un modelo que solo puede explicar apenas poco m치s del 10% de la variabilidad de los datos. Esto significa que alrededor del 90% del comportamiento de la Escala Socioemocional del INDI se debe a factores no considerados dentro de este estudio. 

1. Se encontr칩 algunas variables significativas, lo que sugiere que edad, regi칩n, departamento, nivel socioecon칩mico y educaci칩n materna tienen impacto en el desarrollo socioemocional.

1. La edad es un factor clave en el desarrollo socioemocional, lo que refuerza la importancia de las experiencias y el crecimiento en esta etapa de la vida.

1. Los ni침os de la Sierra muestran mayor desarrollo socioemocional, lo que podr칤a estar relacionado con factores culturales o sociales.

1. Los ni침os que viven en Lima Metropolitana, Loreto y Piura tienen puntajes significativamente m치s altos que los de otros departamentos.

1. El nivel socioecon칩mico influye en el desarrollo socioemocional, con un mayor impacto en el tercer y quinto quintil.

1. El nivel educativo de la madre es un factor clave: a mayor nivel educativo materno, mayor desarrollo socioemocional del ni침o. Los ni침os cuyas madres tienen posgrado (maestr칤a o doctorado) tienen los puntajes m치s altos.

1. El nivel educativo del padre no tiene un impacto significativo en este modelo.
  

\newpage


## An치lisis 4: Escala Disposicional como Variable Dependiente

A continuaci칩n determinaremos qu칠 tan 칰til es un an치lisis de regresi칩n para intentar explicar/predecir los puntajes en la escala Motora del INDI a partir de las variables independientes ya mencionadas.  

```{r 45_P4_REG_DSUM, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE, results='asis'}
regmulti(PULCRO, PULCRO$Escala_Dis., c(6:14), nombres_vars = c("Edad en Meses", "Regi칩n", "츼rea", "Modalidad", "Departamento", "Quintil", "Educac. Materna", "Educac. Paterna", "Instrucci칩n Previa"), nombre_dep = "Escala Disposicional")

# Exportar sin incluir nombres de fila
# write.csv(PULCRO, "PULCRO_MEDMOD.csv", row.names = FALSE)

```

La informaci칩n anterior nos indica que:

1. Usar todas las variables que hemos recolectado para predecir el puntaje en la Escala Disposicional del INDI nos genera un modelo que solo puede explicar algo m치s del 16% de la variabilidad de los datos. Esto significa que casi el 84% del comportamiento de la Escala Disposicional del INDI se debe a factores no considerados dentro de este estudio. 
1. Las 칰nicas variables medidas que realmente aportan a la explicaci칩n del puntaje en la Escala Cognitiva INDI son: 
  
  a. Edad
  a. Departamento
  a. Que el participante sea de Modalidad Jard칤n
  a. Quintil 2 (en detrimento)
  a. Que la madre tenga un nivel educativo de Postgrado
  





  