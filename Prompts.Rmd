---
title: "Prompts"
author: "Martín Vargas Estrada"
date: "`r Sys.Date()`"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

En el contexto del lenguaje de programación estadística R, 
## Spearman

Necesito que generes una función que evalúe la correlación Spearman entre una serie de variables numéricas, por un lado, y una única variable numérica, por el otro. Llamemos "X" a las variables numéricas múltiples, y "Y" a la única variable contra la cual se va a evaluar la asociación o correlación. Por ejemplo, las variables "X" podrían ser Puntaje en el curso de Matemática(M), Puntaje en el curso de Lenguaje(L), y Puntaje en el curso de Idiomas(I). La variable "Y" podría ser: Coeficiente Intelectual(CI). Entonces las correlaciones a calcular serían: M y CI; L y CI, I y CI. 

La idea es que los parámetros sean: 

1. Dataframe
2. Variables "X" (una o más)
3. Variable "Y" (solo una)

El resultado debería ser una tabla de doble entrada con los nombres de las variables "X" en las filas, y tres columnas. La primera debe llamarse "Índice", y contendrá el valor del índice rho; la segunda "Magnitud", y contendrá el valor según lo que indico más abajo; la tercera columna debe llamarse "Significación" y debe contener el nivel de significancia estadística (según lo usual: ***,  **, *, NS).

Para la magnitud, básate en lo siguiente (valores absolutos): 

1. Si 0 ≥ rho > 0.1 La magnitud es nula
2. Si 0.1 ≥ rho > 0.2 La magnitud es muy débil
3. Si 0.2 ≥ rho > 0.3 La magnitud es débil
4. Si 0.3 ≥ rho > 0.5 La magnitud es moderada
5. Si 0.5 ≥ rho > 0.7 La magnitud es fuerte
6. Si 0.7 ≥ rho > 1.0 La magnitud es muy fuerte

Para el sentido, básate en lo siguiente: 
a. Si rho > 0, la asociación es directa
b. Si rho < 0, la asociación es inversa

Luego de la tabla, deberás generar un primer párrafo que enumere las correlaciones que hayan sido estadísticamente significativas, así como las que no lo han sido. Ejemplo: "La siguiente correlación resultó no ser estadísticamente significativa: Puntaje en el curso de Matemática y CI. Por otro lado, las siguientes sí resultaron ser estadísticamente significativas: Puntaje en el curso de Lenguaje y CI; y Puntaje en el curso de Idiomas y CI. 

Luego, debes escribir sendos párrafos con la interpretación de cada índice rho que sea estadísticamente significativo. Asimismo, debes tomar en cuenta el signo del índice rho (positivo o negativo). Cada párrafo deberá enunciar la interpretación de cada una de las correlaciones a partir de la magnitud y el sentido. Por ejemplo, asumamos que la correlación entre Puntaje en el curso de Lenguaje y CI es 0.41, y la la correlación entre Puntaje en el curso de Idiomas y CI es -0.23. Entonces en este caso la interpretación sería: "A continuación pasaremos a analizar el detalle de las correlaciones estadísticamente significativas. La asociación entre Puntaje en el curso de Lenguaje y CI es moderada y directa; esto implica que a mayor puntaje en el curso de Lenguaje, la persona suele tener mayores puntajes en CI. Mientras que la asociación entre Puntaje en el curso de Idiomas  y CI es débil e inversa; esto implica que a mayor puntaje en el curso de Idiomas, la persona suele tener mayores pountajes de CI. "

Asume que el data frame solo contendrá valores numéricos sin NAs. 

Me puedes hacer todas las preguntas que consideres necesarias para dar tu mejor resultado.

## Respuestas

1. Puedes referirte a las variables usando el número de columnas, por ejemplo, las variables X podrían ser c(2:5), mientras que la variable Y podría ser c(6).
2. La tabla debe estar en formato Flextable compatible con Ms Word. Imprímerlo directamente, no hay necesidad de guardarlo como objeto.
3. Sí, puedes asumir los valores estándar de significancia (p < 0.001 = "", p < 0.01 = "", p < 0.05 = "", p ≥ 0.05 = "NS")
4. Sí, es necesario incluir ejemplos detallados para cada asociación estadísticamente significativa, tal como expliqué en el ejemplo.

### Spearman v2

En la función "corre_anal", definida según lo siguiente:

# Función para calcular y analizar las correlaciones de Spearman con formato Markdown ajustado
corre_anal <- function(data, variables_X, variable_Y) {
  resultados <- data.frame(Variable_X = character(), Rho = numeric(), Magnitud = character(), 
                           Significacion = character(), stringsAsFactors = FALSE)
  
  # Iterar sobre las variables X
  for (var in variables_X) {
    test <- cor.test(data[[var]], data[[variable_Y]], method = "spearman")
    rho <- test$estimate
    p_value <- test$p.value
    
    # Determinar la magnitud de rho
    magnitud <- ifelse(abs(rho) > 0.7, "Muy fuerte",
                       ifelse(abs(rho) > 0.5, "Fuerte",
                              ifelse(abs(rho) > 0.3, "Moderada",
                                     ifelse(abs(rho) > 0.2, "Débil",
                                            ifelse(abs(rho) > 0.1, "Muy débil", "Nula")))))
    
    # Determinar la significación estadística
    significacion <- ifelse(p_value < 0.001, "***",
                            ifelse(p_value < 0.01, "**",
                                   ifelse(p_value < 0.05, "*", "NS")))
    
    # Agregar los resultados a la tabla
    resultados <- rbind(resultados, data.frame(
      Variable_X = colnames(data)[var],
      Rho = round(rho, 2),  # Redondear a dos decimales
      Magnitud = magnitud,
      Significacion = significacion
    ))
  }
  
  # Crear la tabla en formato Markdown
  markdown_tabla <- paste0(
    "| Variable X        | Índice Rho | Magnitud     | Significación |\n",
    "|-------------------|------------|--------------|---------------|\n"
  )
  for (i in 1:nrow(resultados)) {
    fila <- resultados[i, ]
    # Alinear Rho a la derecha añadiendo espacios si es necesario
    rho_formateado <- sprintf("%6.2f", fila$Rho)
    markdown_tabla <- paste0(markdown_tabla,
                             "| ", fila$Variable_X, 
                             " | ", rho_formateado, 
                             " | ", fila$Magnitud, 
                             " | ", fila$Significacion, "         |\n")
  }
  
  # Generar interpretaciones textuales
  significativas <- resultados[resultados$Significacion != "NS", ]
  no_significativas <- resultados[resultados$Significacion == "NS", ]
  
  texto <- ""
  if (nrow(no_significativas) > 0) {
    texto <- paste(texto, "La(s) siguiente(s) correlación(es) no fueron estadísticamente significativas:")
    texto <- paste(texto, paste(no_significativas$Variable_X, collapse = ", "), ".")
  }
  
  if (nrow(significativas) > 0) {
    texto <- paste(texto, "Por otro lado, las siguientes correlaciones sí resultaron estadísticamente significativas:")
    texto <- paste(texto, paste(significativas$Variable_X, collapse = ", "), ".")
    
    texto <- paste(texto, "\n\nA continuación, pasaremos a analizar el detalle de las correlaciones estadísticamente significativas.\n")
    for (i in 1:nrow(significativas)) {
      detalle <- significativas[i, ]
      signo <- ifelse(detalle$Rho > 0, "directa", "inversa")
      interpretacion <- paste0(
        "La asociación entre ", detalle$Variable_X, " y ", colnames(data)[variable_Y],
        " es ", detalle$Magnitud, " y ", signo, 
        "; esto implica que a mayor puntaje en ", detalle$Variable_X, 
        ", la persona suele tener ", ifelse(signo == "directa", "mayores", "menores"),
        " puntajes en ", colnames(data)[variable_Y], ".\n"
      )
      texto <- paste(texto, interpretacion)
    }
  }
  
  # Imprimir la tabla en formato Markdown y las interpretaciones
  cat(markdown_tabla, "\n")
  cat(texto, "\n")
}

Necesito que hagas los siguientes ajustes: cuando la magnitud del índice rho sea nula, auqnue sea estadísticamente significativa:

- Añade la frase siguiente justo después de mencionar las correlaciones no estadísticamente significativas: "Por otro lado, la(s) siguiente(s) correlaciones, si bien técnicamente significativa(s), son de magnitud tan pequeño que no indican ninguna asociación en la práctica: {menciona el nombre de la(s) variable(s) independiente(s) del caso, separadas por comas}", 
- No la incluya esas correlaciones en los subsiguientes párrafos de interpretación. 

Asimismo, la división en párrafos para la interpretación de cada índice rho ha dado resultado. Mejórala intercalando puntos aparte y añadiendo una viñeta o bullet point al principio de cada interpretación.

Me puedes hacer todas las preguntas que consideres necesarias para dar tu mejor resultado.

## Prompt para Dunn Test

Crea una función que ejecute un Dunn Test. Los parámetros deben ser el dataframe, y las variables de datos y grupo, identificadas con el número de columna.

El output o salida debe llevar como título "Análisis Dunn de las diferencias estadísticamente significativas" y debe ser una matriz de doble entrada, donde las filas deben ser la(s) variables de datos, y las columnas deben ser como sigue: 

1. La primera columna debe llamarse "Significación" y debe contener el nivel de significancia estadística del p-valor (según lo usual: ***,  **, *, NS)
2. La segunda columna debe llamarse "Diferencia Real Probable", y debe contener los valores "Sí" (si el p-valor es menor a 0.05) o "No" si el p-valor es igual o mayor a 0.05.

Me puedes hacer todas las preguntas que consideres necesarias para dar tu mejor resultado.

## Prompt para seleccionar data numérica destinada a una TED

En el contexto del lenguaje de programación estadística R, necesito que me generes una función que me permita:

1. Seleccionar una serie de variables numéricas a partir de un dataframe
1. Filtrar todos los casos de "NA" que aparezcan (eliminarlos) para cualesquiera de las variables.
1. Los prompts deben ser: 
  * El nombre del dataframe
  * Las columnas en donde están las variables (identificadas por el número de columna)

Me puedes hacer todas las preguntas que consideres necesarias para dar tu mejor resultado.

## Prompt para boxplot

Necesito que crees una función que genere gráficos boxplot orientados en formato horizontal ("echados"). La función debe ser capaz de generar boxplots uno debajo del otro a fin de comparar las distribuciones de las variables. Cada boxplot deberá estar coloreado según la paleta RColorBrewer que yo escoja, siendo el valor de paleta por defecto "Dark2".

Los prompts para la función deben ser: 

* El nombre del dataframe
* El rango de columnas numéricas a graficar.

Me puedes hacer todas las preguntas que consideres necesarias para dar tu mejor resultado.

Etiquetas de los ejes:

    ¿Prefieres que las etiquetas de cada boxplot sean los nombres de las columnas seleccionadas? Sí
    ¿Quieres personalizar el título del gráfico o las etiquetas de los ejes, o dejo valores por defecto (e.g., "Boxplots de las Variables")? Añade un prompt que me permita definir cuál será el título

Personalización del diseño:

    ¿Debería ajustarse automáticamente el tamaño de la figura en función del número de variables seleccionadas? Sí
    ¿Necesitas incluir una leyenda o alguna información adicional en el gráfico? No

Paleta de colores:

    La paleta predeterminada será "Dark2". ¿Quieres que la función valide si la paleta especificada existe en RColorBrewer y genere un mensaje de error si no es válida? No
    
## Para AFC

Necesito generar una función que me permita ejecutar un análisis factorial confirmatorio (en adelante "AFC") usando el paquete lavaan, según lo siguiente:

* Los argumentos deben ser: el nombre del dataframe, el nombre de cada factor, los indicadores para cada factor y el nombre del objeto R que contendrá los resultados. 
* El dataframe no contendrá valores perdidos y estará compuesto exclusivamente por variables numéricos en columnas. De eso me encargo yo.
* El argumento "nombre de factor" estará compuesto por un vector compuesto por cadenas de caracteres. Por ejemplo: c("Factor1", "Factor 2", "Factor 3")
* El argumento "indicadores de cada factor" estará compuesto por un vector para cada factor, el cual contendrá el número que identifica a las columnas que componen el factor. El vector contendrá los números que identifican a las variables. Por ejemplo, para el factor 1 se denotaría por c(1:10); para el factor 2 se denotaría c(11:20), etc.
* El argumento "nombre del objeto R que contendrá los resultados" estará definido como una cadena de caracteres que yo definiré cada vez.

Me puedes hacer todas las preguntas que consideres necesarias para dar tu mejor resultado.

### Responses

1. Sí
2. Sí
3. Sí, quiero los resultados estandarizados.

## Results for CFA


Necesito que tomes esta función:

AFC <- function(data, factors, indicators, result_object_name) {
  # Verificar que la longitud de `factors` coincida con la longitud de `indicators`
  if (length(factors) != length(indicators)) {
    stop("El número de factores debe coincidir con el número de listas de indicadores.")
  }
  
  # Generar la sintaxis del modelo automáticamente
  modelo <- ""
  for (i in seq_along(factors)) {
    factor_name <- factors[i]
    column_indices <- indicators[[i]]
    
    # Convertir los índices a nombres de las columnas
    variable_names <- colnames(data)[column_indices]
    variables <- paste(variable_names, collapse = " + ")
    modelo <- paste0(modelo, factor_name, " =~ ", variables, "\n")
  }
  
  # Ajustar el modelo usando lavaan::cfa()
  ajuste <- cfa(modelo, data = data)
  
  # Mostrar un resumen de resultados con índices de ajuste y resultados estandarizados
  summary(ajuste, fit.measures = TRUE, standardized = TRUE)
  
  # Guardar el objeto con los resultados en el entorno global
  assign(result_object_name, ajuste, envir = .GlobalEnv)
  
  # Retornar el objeto de ajuste
  return(ajuste)
}

Y la modifiques para añadir un aergumento adicional, llamado "Nombre de la escala", el cual será una cadena de texto que yo definiré con la estructura: c("Nombre de la escala"). 

Además, ahora el resultado final de la función ahora deberá ser una tabla titulada **Resumen de Índices de Bondad de Ajuste para el AFC de la {Nombre de la Escala}**, en rMarkdown formateable con kable, según lo siguiente:

| **Índice**   |**Índice Obtenido**| **Nivel Obtenido**|
|--------------|-------------------|-------------------|
| RMSEA        |  (valor)          | (evaluación)      |
| CFI          |  (valor)          | (evaluación)      |
| TLI/NNFI     |  (valor)          | (evaluación)      |
| SRMR         |  (valor)          | (evaluación)      |
| GFI          |  (valor)          | (evaluación)      |


Para definir qué poner en la columna "Nivel Obtenido", usa la tabla siguiente como guía:

| **Índice**   | **Nivel Excelente**       | **Nivel Aceptable**    |
|--------------|---------------------------|------------------------|
| RMSEA        | ≤ 0.05                    | 0.05–0.08              |
| CFI          | ≥ 0.95                    | ≥ 0.90                 |
| TLI/NNFI     | ≥ 0.95                    | ≥ 0.90                 |
| SRMR         | ≤ 0.08                    | ≤ 0.10                 |
| GFI          | ≥ 0.95                    | ≥ 0.90                 |

Me puedes hacer todas las preguntas que consideres necesarias para dar tu mejor resultado.

### CFA p3

En la función siguiente:

AFC <- function(data, factors, indicators, result_object_name, scale_name) {
  # Verificar que la longitud de `factors` coincida con la longitud de `indicators`
  if (length(factors) != length(indicators)) {
    stop("El número de factores debe coincidir con el número de listas de indicadores.")
  }

  # Generar la sintaxis del modelo automáticamente
  modelo <- ""
  for (i in seq_along(factors)) {
    factor_name <- factors[i]
    column_indices <- indicators[[i]]

    # Convertir los índices a nombres de las columnas
    variable_names <- colnames(data)[column_indices]
    variables <- paste(variable_names, collapse = " + ")
    modelo <- paste0(modelo, factor_name, " =~ ", variables, "\n")
  }

  # Ajustar el modelo usando lavaan::cfa()
  ajuste <- cfa(modelo, data = data)

  # Obtener índices de ajuste relevantes
  fit_indices <- fitmeasures(ajuste, c("rmsea", "cfi", "tli", "srmr", "gfi"))

  # Función auxiliar para evaluar el nivel obtenido
  evaluar_indice <- function(indice, valor) {
    case_when(
      indice == "rmsea" & valor <= 0.05 ~ "Excelente",
      indice == "rmsea" & valor <= 0.08 ~ "Aceptable",
      indice == "cfi" & valor >= 0.95 ~ "Excelente",
      indice == "cfi" & valor >= 0.90 ~ "Aceptable",
      indice == "tli" & valor >= 0.95 ~ "Excelente",
      indice == "tli" & valor >= 0.90 ~ "Aceptable",
      indice == "srmr" & valor <= 0.08 ~ "Excelente",
      indice == "srmr" & valor <= 0.10 ~ "Aceptable",
      indice == "gfi" & valor >= 0.95 ~ "Excelente",
      indice == "gfi" & valor >= 0.90 ~ "Aceptable",
      TRUE ~ "Deficiente"
    )
  }

  # Crear tabla con resultados
  resultados_tabla <- data.frame(
    "Índice" = c("RMSEA", "CFI", "TLI/NNFI", "SRMR", "GFI"),
    "Índice Obtenido" = c(fit_indices["rmsea"], 
                          fit_indices["cfi"], 
                          fit_indices["tli"], 
                          fit_indices["srmr"], 
                          fit_indices["gfi"]),
    "Nivel Obtenido" = c(
      evaluar_indice("rmsea", fit_indices["rmsea"]),
      evaluar_indice("cfi", fit_indices["cfi"]),
      evaluar_indice("tli", fit_indices["tli"]),
      evaluar_indice("srmr", fit_indices["srmr"]),
      evaluar_indice("gfi", fit_indices["gfi"])
    )
  )

  # Guardar el objeto con los resultados en el entorno global
  assign(result_object_name, ajuste, envir = .GlobalEnv)

  # Mostrar título y tabla formateada
  cat("\n### Resumen de Índices de Bondad de Ajuste para el AFC de la", scale_name, "\n\n")
  print(kable(resultados_tabla, align = "c", caption = paste("Resumen de Índices de Bondad de Ajuste para el AFC de la", scale_name)))
}

La tabla final resultante contiene una columna inicial en la que se repiten los nombres de los índices de ajuste. ¿Puedes reformular la función para que esa columna inicial no se muestre?



### CFA p4

A partir de la función siguiente:

AFC <- function(data, factors, indicators, result_object_name, scale_name) {
  # Verificar que la longitud de `factors` coincida con la longitud de `indicators`
  if (length(factors) != length(indicators)) {
    stop("El número de factores debe coincidir con el número de listas de indicadores.")
  }

  # Generar la sintaxis del modelo automáticamente
  modelo <- ""
  for (i in seq_along(factors)) {
    factor_name <- factors[i]
    column_indices <- indicators[[i]]

    # Convertir los índices a nombres de las columnas
    variable_names <- colnames(data)[column_indices]
    variables <- paste(variable_names, collapse = " + ")
    modelo <- paste0(modelo, factor_name, " =~ ", variables, "\n")
  }

  # Ajustar el modelo usando lavaan::cfa()
  ajuste <- cfa(modelo, data = data)

  # Obtener índices de ajuste relevantes
  fit_indices <- fitmeasures(ajuste, c("rmsea", "cfi", "tli", "srmr", "gfi"))

  # Función auxiliar para evaluar el nivel obtenido
  evaluar_indice <- function(indice, valor) {
    case_when(
      indice == "rmsea" & valor <= 0.05 ~ "Excelente",
      indice == "rmsea" & valor <= 0.08 ~ "Aceptable",
      indice == "cfi" & valor >= 0.95 ~ "Excelente",
      indice == "cfi" & valor >= 0.90 ~ "Aceptable",
      indice == "tli" & valor >= 0.95 ~ "Excelente",
      indice == "tli" & valor >= 0.90 ~ "Aceptable",
      indice == "srmr" & valor <= 0.08 ~ "Excelente",
      indice == "srmr" & valor <= 0.10 ~ "Aceptable",
      indice == "gfi" & valor >= 0.95 ~ "Excelente",
      indice == "gfi" & valor >= 0.90 ~ "Aceptable",
      TRUE ~ "Deficiente"
    )
  }

  # Crear tabla con resultados (sin la columna con nombres de índices)
  resultados_tabla <- data.frame(
    "Índice Obtenido" = c(fit_indices["rmsea"], 
                          fit_indices["cfi"], 
                          fit_indices["tli"], 
                          fit_indices["srmr"], 
                          fit_indices["gfi"]),
    "Nivel Obtenido" = c(
      evaluar_indice("rmsea", fit_indices["rmsea"]),
      evaluar_indice("cfi", fit_indices["cfi"]),
      evaluar_indice("tli", fit_indices["tli"]),
      evaluar_indice("srmr", fit_indices["srmr"]),
      evaluar_indice("gfi", fit_indices["gfi"])
    )
  )

  # Cambiar nombres de las filas para usar como identificadores
  rownames(resultados_tabla) <- c("RMSEA", "CFI", "TLI/NNFI", "SRMR", "GFI")

  # Guardar el objeto con los resultados en el entorno global
  assign(result_object_name, ajuste, envir = .GlobalEnv)

  # Mostrar título y tabla formateada
  cat("\n### Resumen de Índices de Bondad de Ajuste para el AFC de la", scale_name, "\n\n")
  print(kable(resultados_tabla, align = "c", 
              caption = paste("Resumen de Índices de Bondad de Ajuste para el AFC de la", scale_name)))
}

Añade al resultado de la función una matriz de residuales estandarizados. La tabla adicional de la que hablo deberá llevar por título "Matriz de Residuales estandarizados Escala #", donde el nombre de la escala provendrá del argumento "scale_name" de la función. Rebautiza la función como "AFC2". La tabla adicional deberá ser editable con kable.

Hazme las preguntas que consideres necesarias para darme el mejor resultado posible.


1. 
* Limítate a resaltar únicamente los residuales significativos.
* ¿La tabla debe incluir formateos específicos, como colores para valores altos o bajos? Sí, negritas para valores altos, y cursiva para valores bajos.
2.
* ¿Quieres que la matriz se imprima directamente con kable, o la incluyo como parte de un objeto de salida que puedas inspeccionar y guardar? Imprímelo directamente con kable
* ¿Debe la matriz de residuales ser devuelta como parte de una lista junto con los índices de ajuste y el modelo ajustado? No
3. 
* Actualmente el modelo ajustado se guarda en el entorno global con assign. ¿Quieres mantener este comportamiento o prefieres que la función devuelva una lista con todos los elementos (modelo, índices y matriz de residuales)? Mejor guádalo como una lista tal como describes.
4. 
* Si la escala tiene muchos ítems, la matriz de residuales puede volverse grande. ¿Debo limitar la visualización en pantalla a ciertos ítems clave o dejarla completa? Limita la visualización en pantalla a ciertos ítems clave
5. 
* ¿Debo recalcular los índices de ajuste después de inspeccionar los residuales (por ejemplo, si planeas modificar el modelo según los residuales)? No


# Outliers01

Créame una función usando cñodigo R. La función deberá llamarse "intensos", y deberá hacer lo siguiente:

1. A partir de un data frame compuesto por una serie de variables en columnas y casos en filas, donde cada columna es un ítem, detectar qué casos constituyen outliers o valores atípicos. 


# Outliers02

Tomando la función siguiente como punto de partida:

items_intensos <- function(data, rango_columnas, columna_contexto, multiplicador_IQR = 1.5) {
  # Verificar que las columnas estén en el rango
  columnas_seleccionadas <- names(data)[rango_columnas]
  
  # Identificar columnas no numéricas
  columnas_no_numericas <- columnas_seleccionadas[!sapply(data[, rango_columnas, drop = FALSE], is.numeric)]
  
  # Excluir las columnas no numéricas y avisar
  columnas_a_evaluar <- setdiff(columnas_seleccionadas, columnas_no_numericas)
  if (length(columnas_no_numericas) > 0) {
    cat("Las siguientes columnas no son numéricas y serán excluidas del análisis:\n")
    print(columnas_no_numericas)
  }
  
  # Inicializar una tabla consolidada
  resultados_outliers <- data.frame(
    Columna = character(),
    Fila = integer(),
    Valor_Outlier = numeric(),
    Contexto = character()
  )
  
  # Aplicar la detección de outliers para cada columna numérica
  for (columna in columnas_a_evaluar) {
    # Obtener los datos de la columna
    valores <- data[[columna]]
    
    # Calcular los cuartiles y los límites del IQR
    Q1 <- quantile(valores, 0.25, na.rm = TRUE)
    Q3 <- quantile(valores, 0.75, na.rm = TRUE)
    IQR <- Q3 - Q1
    limite_inferior <- Q1 - multiplicador_IQR * IQR
    limite_superior <- Q3 + multiplicador_IQR * IQR
    
    # Identificar las filas con outliers
    filas_outliers <- which(valores < limite_inferior | valores > limite_superior)
    
    # Crear un data frame con los resultados para esta columna
    if (length(filas_outliers) > 0) {
      resultados <- data.frame(
        Columna = columna,
        Fila = filas_outliers,
        Valor_Outlier = valores[filas_outliers],
        Contexto = data[[columna_contexto]][filas_outliers]
      )
      
      # Consolidar los resultados
      resultados_outliers <- rbind(resultados_outliers, resultados)
    }
  }
  
  # Generar una tabla en Markdown
  if (nrow(resultados_outliers) > 0) {
    cat("### Tabla consolidada de casos con valores atípicos\n")
    kable(resultados_outliers, format = "markdown", row.names = FALSE)
  } else {
    cat("No se detectaron valores atípicos en las columnas evaluadas.\n")
  }
}

Genera una función alternativa, llamada items_intensos_resumen, que genere:

1. Una matriz de doble entrada donde las filas sean los valores con la sumatoria de cuántos casos atípicos existen para cada columna o ítem, de la forma siguiente:
|Ítem    | Valor_Outlier|Frecuencia |
|:-------|-------------:|:----------|
|S6      |             6|          7|
|S6      |             7|          4|
|S7      |             6|          3|
|S79     |             0|          2|

2. Una tabla de frecuencias descendentes del campo "Contexto" con la sumatoria de cuántos casos existen para cada valor diferente, por ejemplo:

|Contexto| Frecuencia|
|:-------|----------:|
|Costa   |          9| 
|Sierra  |          7| 
|Selva   |          6|


Ambas tablas deben ser editables en kable para Markdown.


